import demistomock as demisto
from CommonServerPython import *  # noqa # pylint: disable=unused-wildcard-import
from CommonServerUserPython import *  # noqa

import urllib3
import traceback
from typing import Dict, Any

# Disable insecure warnings
urllib3.disable_warnings()  # pylint: disable=no-member


''' CONSTANTS '''

DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'  # ISO8601 format with UTC, default in XSOAR
# Relevant for api version v1
TIME_PERIOD_MAPPING = {
    'Last 60 Minutes': 3600,
    'Last 24 Hours': 86400,
    'Last 7 Days': 604800,
    'Last 30 Days': 2592000,
    'Last 60 Days': 5184000,
    'Last 90 Days': 7776000
}

''' CLIENT CLASS '''


class Client(BaseClient):
    """
    Client for Netskope RESTful API.

    Args:
        base_url (str): The base URL of Netskope.
        token (str): The token to authenticate against Netskope API.
        validate_certificate (bool): Specifies whether to verify the SSL certificate or not.
        proxy (bool): Specifies if to use XSOAR proxy settings.
    """

    def __init__(self, base_url: str, token: str, api_version: str, validate_certificate: bool, proxy: bool):
        super().__init__(base_url, verify=validate_certificate, proxy=proxy)
        if api_version == 'v1':
            self._session.params['token'] = token
        else:
            self.headers = {'Netskope-Api-Token': token}

    def v1_get_application_events_request(self, timeperiod: Optional[int] = None,
                                          limit: Optional[int] = None) -> Dict[str, Any]:
        """
        Get application events extracted from SaaS traffic and or logs.

        Args:
            timeperiod (Optional[int]): Get all events from a certain time period.
            limit (Optional[int]): The maximum amount of events to retrieve (up to 10000 events).

        Returns:
            Dict[str, Any]: Netskope events.
        """
        url_suffix = 'events'
        body = {'timeperiod': timeperiod, 'limit': limit, 'type': 'application'}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)

    def v1_get_audit_events_request(self, timeperiod: Optional[int] = None,
                                          limit: Optional[int] = None) -> Dict[str, Any]:
        """
        Get audit events extracted from SaaS traffic and or logs.

        Args:
            timeperiod (Optional[int]): Get all events from a certain time period.
            limit (Optional[int]): The maximum amount of events to retrieve (up to 10000 events).

        Returns:
            Dict[str, Any]: Netskope events.
        """
        url_suffix = 'events'
        body = {'timeperiod': timeperiod, 'limit': limit, 'type': 'audit'}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)

    def v1_get_network_events_request(self, timeperiod: Optional[int] = None,
                                      limit: Optional[int] = None) -> Dict[str, Any]:
        """
        Get network events extracted from SaaS traffic and or logs.

        Args:
            timeperiod (Optional[int]): Get all events from a certain time period.
            limit (Optional[int]): The maximum amount of events to retrieve (up to 10000 events).

        Returns:
            Dict[str, Any]: Netskope events.
        """
        url_suffix = 'events'
        body = {'timeperiod': timeperiod, 'limit': limit, 'type': 'network'}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)

    def v1_get_alerts_request(self, timeperiod: Optional[int] = None, limit: Optional[int] = None):
        """
        Get alerts generated by Netskope, including policy, DLP, and watch list alerts.

        Args:
            timeperiod (Optional[int]): Get alerts from certain time period.
            limit (Optional[int]): The maximum number of alerts to return (up to 10000).

        Returns:
            Dict[str, Any]: Netskope alerts.
        """

        url_suffix = 'alerts'
        body = {'timeperiod': timeperiod, 'limit': limit}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)

    def v2_get_alert_events_request(self, timeperiod: Optional[int] = None, limit: Optional[int] = None):
        """
        Get events of type alert generated by Netskope.

        Args:
            timeperiod (Optional[int]): Get alerts from certain time period.
            limit (Optional[int]): The maximum number of events to return (up to 10000).

        Returns:
            Dict[str, Any]: Netskope events.
        """
        url_suffix = 'events/data/alert'
        body = {'timeperiod': timeperiod, 'limit': limit}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)

    def v2_get_network_events_request(self, timeperiod: Optional[int] = None, limit: Optional[int] = None):
        """
        Get events of type network generated by Netskope.

        Args:
            timeperiod (Optional[int]): Get alerts from certain time period.
            limit (Optional[int]): The maximum number of events to return (up to 10000).

        Returns:
            Dict[str, Any]: Netskope events.
        """
        url_suffix = 'events/data/network'
        body = {'timeperiod': timeperiod, 'limit': limit}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)

    def v2_get_audit_events_request(self, timeperiod: Optional[int] = None, limit: Optional[int] = None):
        """
        Get events of type audit generated by Netskope.

        Args:
            timeperiod (Optional[int]): Get alerts from certain time period.
            limit (Optional[int]): The maximum number of events to return (up to 10000).

        Returns:
            Dict[str, Any]: Netskope events.
        """
        url_suffix = 'events/data/audit'
        body = {'timeperiod': timeperiod, 'limit': limit}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)

    def v2_get_application_events_request(self, timeperiod: Optional[int] = None, limit: Optional[int] = None):
        """
        Get events of type application generated by Netskope.

        Args:
            timeperiod (Optional[int]): Get alerts from certain time period.
            limit (Optional[int]): The maximum number of events to return (up to 10000).

        Returns:
            Dict[str, Any]: Netskope events.
        """
        url_suffix = 'events/data/application'
        body = {'timeperiod': timeperiod, 'limit': limit}

        return self._http_request(method='GET', url_suffix=url_suffix, json_data=body)


''' HELPER FUNCTIONS '''


def arg_to_seconds_timestamp(arg: Optional[str]) -> Optional[int]:
    """
    Converts an XSOAR date string argument to a timestamp in seconds.

    Args:
        arg (Optional[str]): The argument to convert.

    Returns:
        Optional[int]: A timestamp if arg can be converted,
        or None if arg is None.
    """

    if arg is None:
        return None

    return date_to_seconds_timestamp(arg_to_datetime(arg))


def date_to_seconds_timestamp(date_str_or_dt: Union[str, datetime]) -> int:
    """
    Converts date string or datetime object to a timestamp in seconds.

    Args:
        date_str_or_dt (Union[str, datetime]): The datestring or datetime.

    Returns:
        int: The timestamp in seconds.
    """

    return date_to_timestamp(date_str_or_dt) // 1000


''' COMMAND FUNCTIONS '''


def test_module(client: Client, api_version: str) -> str:
    if api_version == 'v1':
        response = client.v1_get_alerts_request(limit=1, timeperiod=2592000)  # timeperiod - Last 30 days
    else:
        response = client.v2_get_alert_events_request(timeperiod=2592000, limit=1)

    if response.get('status') == 'success':
        return 'ok'
    else:
        return f'Test failed - {response.get("errorCode")}, {response.get("errors")}'


def v1_get_events_command(client: Client, args: Dict[str, Any]) -> CommandResults:
    limit = arg_to_number(args.get('limit', 20))
    timeperiod = TIME_PERIOD_MAPPING.get(args.get('timeperiod'))
    application_result = client.v1_get_application_events_request(timeperiod, limit)
    outputs = application_result.get('data', [])
    alert_results = client.v1_get_alerts_request(timeperiod, limit)
    alert_output = alert_results.get('data', [])
    outputs.extend(alert_output)
    audit_results = client.v1_get_audit_events_request(timeperiod, limit)
    audit_output = audit_results.get('data', [])
    outputs.extend(audit_output)
    network_results = client.v1_get_network_events_request(timeperiod, limit)
    network_output = network_results.get('data', [])
    outputs.extend(network_output)

    for event in outputs:
        event['timestamp'] = timestamp_to_datestring(event['timestamp'] * 1000)

    readable_output = tableToMarkdown('Events List:', outputs,
                                      removeNull=True,
                                      headers=['_id', 'timestamp', 'type', 'access_method', 'app', 'traffic_type'],
                                      headerTransform=string_to_table_header)

    return CommandResults(outputs_prefix='Netskope.Event',
                          outputs_key_field='_id',
                          outputs=outputs,
                          readable_output=readable_output,
                          raw_response=outputs)

def fetch_events_v1():


def v2_get_events_command(client: Client, args: Dict[str, Any]) -> CommandResults:
    limit = arg_to_number(args.get('limit', 50))
    timeperiod = arg_to_seconds_timestamp(args.get('timeperiod', 259200))
    event_type = args.get('event_type')
    response = {}
    if event_type == 'alert':
        response = client.v2_get_alert_events_request(timeperiod, limit)
    elif event_type == 'network':
        response = client.v2_get_network_events_request(timeperiod, limit)
    elif event_type == 'audit':
        response = client.v2_get_audit_events_request(timeperiod, limit)
    elif event_type == 'application':
        response = client.v2_get_application_events_request(timeperiod, limit)

    result = response.get('result', [])

    return CommandResults(
        outputs_prefix='Netskope.Event',
        outputs_key_field='_id',
        readable_output=f'Events List: {result}',
        outputs=result,
        raw_response=response
    )


''' MAIN FUNCTION '''


def main() -> None:
    params = demisto.params()

    url = params.get('url')
    api_version = params.get('api_version')
    token = demisto.params().get('credentials', {}).get('password')
    base_url = urljoin(url, f'/api/{api_version}/')
    verify_certificate = not demisto.params().get('insecure', False)
    proxy = demisto.params().get('proxy', False)
    first_fetch = params.get('first_fetch')
    vendor, product = params.get('vendor'), params.get('product')

    demisto.debug(f'Command being called is {demisto.command()}')
    try:
        client = Client(base_url, token, api_version, verify_certificate, proxy)

        if demisto.command() == 'test-module':
            # This is the call made when pressing the integration Test button.
            result = test_module(client, api_version)
            return_results(result)

        elif demisto.command() == 'netskope-get-events':
            if api_version == 'v1':
                return_results(v1_get_events_command(client, demisto.args()))
            else:
                return_results(v2_get_events_command(client, demisto.args()))
        elif demisto.command() == 'fetch-events':
            if api_version == 'v1':
                send_events_to_xsiam()

    # Log exceptions and return errors
    except Exception as e:
        demisto.error(traceback.format_exc())  # print the traceback
        return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


''' ENTRY POINT '''


if __name__ in ('__main__', '__builtin__', 'builtins'):
    main()
